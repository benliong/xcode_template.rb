# simple helper to generate an iPhone model complete with initialiser for JSON dictionary
# to work with a rails backend

class XcodeTemplate < ActiveRecord::Base
  self.abstract_class = true
  def self.xcode
    cname = self.name
    path =  "#{::Rails.root}/#{cname}"
    mpath = "#{path}.m"
    hpath = "#{path}.h"
    rpath = "#{path}-to-json.rb"
    
    # write header file

    hfile = File.open(hpath,"w")

    hfile.puts "// --------------------------------------------------------------------------------------"
    hfile.puts "// #{cname} - ObjC Model Declaration based on Ruby on Rails model"
    hfile.puts "// generated by XcodeTemplate helper (c) jTribe Holdings Pty Ltd 2011 - www.jtribe.com.au"
    hfile.puts "// --------------------------------------------------------------------------------------"
    hfile.puts
    hfile.puts "#import <Foundation/Foundation.h>"
    hfile.puts
    hfile.puts "@interface #{cname} : NSObject {"


    classmap = { :integer => 'NSInteger', :boolean => 'BOOL', :string => 'NSString',
                 :date => 'NSDate', :datetime => 'NSDate', :text => 'NSString' }

    prefixmap = {  :integer => '', :boolean => '', :string => '*_',
                 :date => '*_', :datetime => '*_', :text => '*_' }

    defaultmap = {  :integer => '0', :boolean => 'NO', :string => 'nil',
                 :date => 'nil', :datetime => 'nil', :text => 'nil' }

    storagemap = {  :integer => '(assign)', :boolean => '(assign)', :string => '(nonatomic,retain)',
                    :date => '(nonatomic,retain)', :datetime => '(nonatomic,retain)', :text => '(nonatomic,retain)' }


    columns = self.columns.sort { |a,b| a.name <=> b.name }

    have_dates = false

    for col in columns
      sym = col.type
      cn = classmap[sym]
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      if cn.nil?
        puts "Sorry, don't know how to map object of type '#{col.type}' - mapping to a string."
        sym = :string
      end

      have_dates = true if (classmap[sym] == "NSDate")

      hfile.puts "   #{classmap[sym].ljust(12)} #{prefixmap[sym]}#{name};"
    end

    hfile.puts "}"
    hfile.puts
    hfile.puts "-(id)initWithDictionary:(NSDictionary *)dictionary;"
    hfile.puts
    hfile.puts
      for col in columns
      sym = col.type
      cn = classmap[sym]
      if cn.nil?
        sym = :string
      end
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      ppfix = (prefixmap[sym].blank?)?'':'*'
      hfile.puts "@property #{storagemap[sym].ljust(20)} #{classmap[sym].ljust(12)} #{ppfix}#{name};"
    end

    hfile.puts
    hfile.puts "@end"
    hfile.close

    # write implementation file

    mfile = File.open(mpath,"w")

    mfile.puts "// --------------------------------------------------------------------------------------"
    mfile.puts "// #{cname} - ObjC Model Implementation based on Ruby on Rails model"
    mfile.puts "// generated by XcodeTemplate helper (c) jTribe Holdings Pty Ltd 2011 - www.jtribe.com.au"
    mfile.puts "// --------------------------------------------------------------------------------------"
    mfile.puts
    mfile.puts "#import \"#{cname}.h\""
    mfile.puts
    mfile.puts "@implementation #{cname}"
    mfile.puts

    for col in columns
      sym = col.type
      cn = classmap[sym]
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      if cn.nil?
        sym = :string
      end
      if prefixmap[sym].blank?
        mfile.puts "@synthesize #{name};"
      else
        mfile.puts "@synthesize #{name} = _#{name};"
      end
    end

    mfile.puts
    mfile.puts
    mfile.puts "// designated initializer"
    mfile.puts
    mfile.puts "-(id)initWithDictionary:(NSDictionary*)dictionary"
    mfile.puts "{"
    mfile.puts "    if ((self = [super init]) == nil) { return nil; }"
    mfile.puts
    mfile.puts "    // initialise ivars"

    mfile.puts

    # defaults
    for col in columns
      sym = col.type
      cn = classmap[sym]
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      if cn.nil?
        sym = :string
      end
      if prefixmap[sym].blank?
        mfile.puts "    #{name} = #{defaultmap[sym]};"
      else
        mfile.puts "    _#{name} = #{defaultmap[sym]};"
      end
    end

    mfile.puts
    mfile.puts "    // initialise object from dictionary attributes from dictionary"
    mfile.puts
    mfile.puts "    if (dictionary)"
    mfile.puts "    {"
    if (have_dates)
      # if we have date columns, we need a date formatter to parse them
      mfile.puts "        NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];"
      mfile.puts "        [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"];"
      mfile.puts
     end

    for col in columns
      sym = col.type
      cn = classmap[sym]
      if cn.nil?
        sym = :string
      end
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      mfile.puts "        if ([dictionary objectForKey:@\"#{name}\"])"
      mfile.puts "        {"
      if (cn == "NSDate")
        mfile.puts "            self.#{name} = [dateFormatter dateFromString:[dictionary objectForKey:@\"#{name}\"]];"
      elsif (cn == "NSString")
        mfile.puts "            self.#{name} = [dictionary objectForKey:@\"#{name}\"];"
      elsif (cn == "NSInteger")
          mfile.puts "            self.#{name} = [[dictionary objectForKey:@\"#{name}\"] intValue];"
      elsif (cn == "BOOL")
            mfile.puts "            self.#{name} = [[dictionary objectForKey:@\"#{name}\"] boolValue];"
      end
      mfile.puts "        }"
      mfile.puts
    end


    if (have_dates)
      # if we have date columns, we need a date formatter to parse them
      mfile.puts
      mfile.puts "        [dateFormatter release];"
      mfile.puts
     end

    mfile.puts "    } // end if dictionary was passed in"
    mfile.puts "    return self;"
    mfile.puts "} // end initWithDictionary"
    mfile.puts
    mfile.puts

    mfile.puts "#pragma mark -"
    mfile.puts "#pragma mark Memory"
    mfile.puts
    mfile.puts "- (id)init"
    mfile.puts "{"
    mfile.puts "    return [self initWithDictionary:nil];"
    mfile.puts "}"
    mfile.puts

    mfile.puts "- (void)dealloc"
    mfile.puts "{"
    mfile.puts
    mfile.puts "    // synthesized setter takes care of release"
    for col in columns
      sym = col.type
      cn = classmap[sym]
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      if cn.nil?
        sym = :string
      end
      if !prefixmap[sym].blank?
        mfile.puts "    self.#{name} = nil;"
      end
    end
  	mfile.puts "    [super dealloc];"
    mfile.puts "}"


    mfile.puts
    mfile.puts "@end"
    mfile.close

    # write to_json helper for the rails model
    rfile = File.open(rpath,"w")
    rfile.puts "# --------------------------------------------------------------------------------------"
    rfile.puts "# as_json method for #{cname} Rails Model - simply remove the attributes"
    rfile.puts "# you do not want to send over the wire - send via render :text => object.to_json"
    rfile.puts "# generated by XcodeTemplate helper (c) jTribe Holdings Pty Ltd 2011 - www.jtribe.com.au"
    rfile.puts "# --------------------------------------------------------------------------------------"
    rfile.puts
    rfile.puts "def as_json"
    rfile.puts "  h = Hash.new"
    for col in columns
      sym = col.type
      cn = classmap[sym]
      name = col.name
      name = "#{self.name.downcase}_id" if (name == 'id')
      if cn.nil?
        sym = :string
      end
      if (cn == "NSDate")
        rfile.puts "  h[:#{name}] = self.#{name}.strftime('%Y-%m-%d %H:%M:%S') if !self.#{name}.nil?"
      else
        rfile.puts "  h[:#{name}] = self.#{name} if !self.#{name}.nil?"
      end
      
    end
    rfile.puts "  return h"
    rfile.puts "end"
    rfile.puts
    rfile.close

    puts "I've created 3 files for you (didn't want to overwrite existing code):"
    puts "#{File.expand_path(hpath)} - the Objective-C declaration file for the #{cname} model of your iPhone App"
    puts "#{File.expand_path(mpath)} - the Objective-C implementation file for the #{cname} model of your iPhone App"
    puts "#{File.expand_path(rpath)} - the as_json method for your Rails model; simply add the code to your existing file"
    puts
    puts "How to use:"
    puts "By default the template includes code to handle all the attributes in your Rails model."
    puts "Simply add the .h and .m file to your XCode project and customise the as_json method of the"
    puts "Rails model by removing any attributes you do not want to send over the wire to the iPhone"
    puts "from the Hash that gets created in the as_json method - you can also remove the corresponding"
    puts "instance variables and properties from the iPhone model if you want to."
    puts
    puts "To send a #{cname} object back to your iPhone app, you simply do:"
    puts
    puts "render :text => #{cname.downcase}.to_json"
    puts
    puts "in your Rails controller (assuming #{cname.downcase} is an object of class #{cname})."
    puts "On the iPhone end you can then use SBJSON to parse the JSON into a dictionary,"
    puts "then simply call the custom initializer initWithDictionary with thet dictionary."
    puts
    puts "Of course this works just as easy with arrays of objects as well!"
    puts
   end
end